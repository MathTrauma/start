<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Euclidean Geometry Problem Viewer</title>

    <!-- Korean Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+KR:wght@400;600;700&display=swap" rel="stylesheet">
    
    <!-- Common Resources -->
    <link rel="stylesheet" href="styles/common.css">

    <!-- Import Map for ES Modules -->
    <script type="importmap">
    {
        "imports": {
            "p5": "https://esm.sh/p5@1.9.4"
        }
    }
    </script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <!-- UI Controls (legacy compatibility) -->
    <script src="https://euclide-worker.painfultrauma.workers.dev/lib/ui-controls.js"></script>
</head>
<body>
    <header class="top-nav">
        <a href="../" class="nav-logo">
            <!-- <i data-lucide="zap" width="18" height="18"></i> -->
            <span>MathMore</span>
        </a>
        <div class="auth-buttons">
            <button id="login-btn" onclick="signInWithGoogle()" style="display: none;">로그인</button>
            <button id="logout-btn" onclick="signOut()" style="display: none;">로그아웃</button>
        </div>
    </header>
    <main>
        <div id="problem-container"></div>
        <div class="canvas-container" id="canvas-wrapper"></div>
        <!-- Solution Panel - Below Canvas -->
        <div id="solution-panel" class="solution-panel hidden">
            <div class="solution-panel-header">
                <span class="solution-panel-title">풀이</span>
                <button id="solution-panel-close" class="solution-panel-close-btn">×</button>
            </div>
            <div class="solution-panel-content" id="solution-text"></div>
        </div>
        <div id="controls-container"></div>
    </main>

    <!-- Supabase & Auth -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="../js/auth.js"></script>
    <script>
        // Lucide 초기화
        lucide.createIcons();

        // 인증 초기화
        const loginBtn = document.getElementById('login-btn');
        const logoutBtn = document.getElementById('logout-btn');

        initAuth((session) => {
            if (session) {
                loginBtn.style.display = 'none';
                logoutBtn.style.display = 'block';
            } else {
                loginBtn.style.display = 'block';
                logoutBtn.style.display = 'none';
            }
        });

        // URL 파라미터에서 문제 ID 추출
        const urlParams = new URLSearchParams(window.location.search);
        const problemId = urlParams.get('problem') || '001';

        // Global variables for text update
        let globalPaddedId;
        let globalBaseUrl;

        // 문제 로드
        loadProblem(problemId);

        // Global state for contest mode
        let isContestMode = false;
        let canvasRevealed = false;

        async function loadProblem(id) {
            const paddedId = id.padStart(3, '0');
            const baseUrl = 'https://euclide-worker.painfultrauma.workers.dev';
            const configUrl = `${baseUrl}/problems/${paddedId}/config.json`;

            // Set global variables for updateProblemText
            globalPaddedId = paddedId;
            globalBaseUrl = baseUrl;

            // 캔버스를 초기에 숨김 (렌더링 안정화)
            const canvasWrapper = document.getElementById('canvas-wrapper');
            canvasWrapper.style.opacity = '0';
            canvasWrapper.style.visibility = 'hidden';

            try {
                const response = await fetch(configUrl);
                const config = await response.json();

                // 문제 텍스트와 UI를 먼저 렌더링
                await renderProblem(config, paddedId, baseUrl);

                // 모든 렌더링 완료 후 스케치 로드 (ES Module)
                const script = document.createElement('script');
                script.type = 'module';
                script.src = `${baseUrl}/problems/${paddedId}/sketch.js`;

                script.onload = () => {
                    // 컨트롤 생성
                    renderControls(config, paddedId, baseUrl);

                    // p5가 첫 프레임을 그릴 때까지 대기 후 캔버스 표시
                    function waitForP5Ready() {
                        if (window._p5Instance && window._p5Instance.frameCount > 0) {
                            if (!isContestMode) {
                                canvasWrapper.style.opacity = '1';
                                canvasWrapper.style.visibility = 'visible';
                            } else {
                                // Contest 모드: 캔버스가 열릴 때까지 애니메이션 정지
                                window._p5Instance.noLoop();
                            }
                        } else {
                            requestAnimationFrame(waitForP5Ready);
                        }
                    }
                    waitForP5Ready();
                };

                document.body.appendChild(script);
            } catch (error) {
                console.error('Failed to load problem:', error);
                document.getElementById('problem-container').innerHTML = `
                    <div class="error-message">
                        <h2>문제를 불러올 수 없습니다</h2>
                        <p>Problem ID: ${id}</p>
                        <p>${error.message}</p>
                    </div>
                `;
            }
        }

        async function renderProblem(config, paddedId, baseUrl) {
            // Pre-rendered HTML 로드
            try {
                const response = await fetch(`${baseUrl}/problems/${paddedId}/problem.html`);
                const html = await response.text();

                // config에서 contest 여부 확인
                isContestMode = config.contest === true;

                // 문제 HTML 생성
                const problemContainer = document.getElementById('problem-container');
                problemContainer.className = 'problem-container';
                problemContainer.innerHTML = `
                    <div class="problem-header">
                        <span class="problem-tag level">Level ${config.level}</span>
                        ${isContestMode ? '<span class="problem-tag contest">Contest</span>' : ''}
                    </div>
                    <div class="problem-content" id="problem-text"></div>
                    ${isContestMode ? '<button id="toggle-canvas-btn" class="toggle-canvas-btn">▼ 그림 보기</button>' : ''}
                `;

                // Pre-rendered HTML 삽입 (MathJax 불필요)
                const problemText = document.getElementById('problem-text');
                problemText.innerHTML = html;

                // Contest 문제면 캔버스 숨김 및 토글 설정
                if (isContestMode) {
                    const canvasWrapper = document.getElementById('canvas-wrapper');
                    canvasWrapper.style.display = 'none';

                    // 토글 버튼 이벤트
                    const toggleBtn = document.getElementById('toggle-canvas-btn');
                    toggleBtn.addEventListener('click', () => {
                        const isHidden = canvasWrapper.style.display === 'none';

                        if (isHidden) {
                            // 캔버스 펼치기
                            canvasWrapper.style.display = 'block';
                            canvasWrapper.style.opacity = '1';
                            canvasWrapper.style.visibility = 'visible';
                            toggleBtn.textContent = '▲ 그림 숨기기';

                            // 애니메이션 시작 (처음 펼칠 때만 리셋)
                            if (!canvasRevealed) {
                                canvasRevealed = true;
                                if (typeof resetAnimation === 'function') {
                                    resetAnimation();
                                }
                            }
                            // p5 루프 시작
                            if (window._p5Instance) {
                                window._p5Instance.loop();
                            }
                        } else {
                            // 캔버스 숨기기
                            canvasWrapper.style.display = 'none';
                            toggleBtn.textContent = '▼ 그림 보기';
                            // p5 루프 정지 (성능 최적화)
                            if (window._p5Instance) {
                                window._p5Instance.noLoop();
                            }
                        }
                    });
                }
            } catch (error) {
                console.error('Failed to load problem text:', error);
            }
        }

        // Update problem text based on current mode and phase
        async function updateProblemText(mode, phase, paddedId, baseUrl) {
            if (mode === 'problem') {
                // Hide solution panel in problem mode
                hideSolutionPanel();

                // Ensure problem text shows problem.html
                const problemText = document.getElementById('problem-text');
                if (!problemText) return;

                try {
                    const response = await fetch(`${baseUrl}/problems/${paddedId}/problem.html`);
                    const html = await response.text();
                    problemText.innerHTML = html;
                } catch (error) {
                    console.error('Failed to load problem text:', error);
                }
            } else if (mode === 'solution') {
                // Show solution panel
                const solutionText = document.getElementById('solution-text');
                if (!solutionText) return;

                let filename;
                if (phase === 'all' || !phase) {
                    filename = 'solution-phase-1.html';
                } else {
                    filename = `solution-phase-${phase}.html`;
                }

                try {
                    const response = await fetch(`${baseUrl}/problems/${paddedId}/${filename}`);
                    if (!response.ok) {
                        console.warn(`Failed to load ${filename}`);
                        hideSolutionPanel();
                        return;
                    }

                    const html = await response.text();
                    solutionText.innerHTML = html;

                    // Show panel
                    showSolutionPanel();
                } catch (error) {
                    console.error('Failed to update solution text:', error);
                    hideSolutionPanel();
                }
            }
        }

        function showSolutionPanel() {
            const panel = document.getElementById('solution-panel');
            if (panel) {
                panel.classList.remove('hidden');
            }
        }

        function hideSolutionPanel() {
            const panel = document.getElementById('solution-panel');
            if (panel) {
                panel.classList.add('hidden');
            }
        }

        function renderControls(config, paddedId, baseUrl) {
            const hasSolution = config.solutionPhases && config.solutionPhases.length > 0;

            const controlsContainer = document.getElementById('controls-container');
            controlsContainer.innerHTML = `
                <div class="controls" id="draggable-controls">
                    <!-- Header with drag handle and collapse -->
                    <div class="controls-header" id="controls-drag-handle">
                        <span class="controls-title">Controls</span>
                        <button class="controls-collapse-btn" id="btn-collapse">−</button>
                    </div>

                    <div class="controls-body">
                        <!-- Mode Toggle -->
                        <div class="control-section">
                            <div class="control-label">Mode</div>
                            <div class="button-group mode-toggle">
                                <button id="btn-mode-problem" class="active mode-btn">Problem</button>
                                <button id="btn-mode-solution" class="mode-btn" ${!hasSolution ? 'disabled' : ''}>Solution</button>
                            </div>
                        </div>

                        <!-- Play Controls -->
                        <div class="control-section">
                            <div class="control-label">Play</div>
                            <div class="button-group">
                                <button id="btn-restart">↺</button>
                                <button id="btn-play-pause">⏸</button>
                            </div>
                        </div>

                        <!-- Phase Buttons -->
                        <div class="control-section">
                            <div class="control-label">Phase</div>
                            <div class="button-group" style="margin-bottom: 4px;">
                                <button id="btn-all" class="active">All</button>
                            </div>
                            <div class="phase-buttons" id="phase-buttons-container">
                                <!-- Dynamically populated -->
                            </div>
                        </div>
                    </div>
                </div>
            `;

            // Setup drag functionality for desktop
            setupDraggable();

            // Render initial phase buttons (problem mode)
            renderPhaseButtons('problem', config.problemPhases ? config.problemPhases.length : config.phases.length);

            // Setup event listeners (must be called after controls are rendered)
            if (typeof setupControls === 'function') {
                setupControls();
            }

            // Setup solution panel close button
            const closeBtn = document.getElementById('solution-panel-close');
            if (closeBtn) {
                closeBtn.addEventListener('click', () => {
                    hideSolutionPanel();
                });
            }
        }

        function renderPhaseButtons(mode, count) {
            const container = document.getElementById('phase-buttons-container');
            container.innerHTML = '';

            for (let i = 1; i <= count; i++) {
                const btn = document.createElement('button');
                btn.id = `btn-phase-${i}`;
                btn.setAttribute('data-phase', i);
                btn.textContent = `${i}`;
                container.appendChild(btn);
            }
        }

        // Draggable controls (desktop only)
        function setupDraggable() {
            const controls = document.getElementById('draggable-controls');
            const handle = document.getElementById('controls-drag-handle');
            const collapseBtn = document.getElementById('btn-collapse');

            if (!controls || !handle) return;

            // Check if mobile (don't enable drag on mobile)
            const isMobile = window.matchMedia('(max-width: 768px)').matches;
            if (isMobile) {
                controls.style.cursor = 'default';
                handle.style.cursor = 'default';
                return;
            }

            let isDragging = false;
            let startX, startY, initialX, initialY;

            // Drag from header
            handle.addEventListener('mousedown', startDrag);

            function startDrag(e) {
                // Don't drag when clicking buttons
                if (e.target.tagName === 'BUTTON') return;
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                const rect = controls.getBoundingClientRect();
                initialX = rect.left;
                initialY = rect.top;
                controls.style.transition = 'none';
                e.preventDefault();
            }

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                e.preventDefault();
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                controls.style.left = (initialX + dx) + 'px';
                controls.style.top = (initialY + dy) + 'px';
                controls.style.right = 'auto';
            });

            document.addEventListener('mouseup', () => {
                isDragging = false;
                controls.style.transition = '';
            });

            // Collapse/expand functionality
            collapseBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                controls.classList.toggle('collapsed');
                collapseBtn.textContent = controls.classList.contains('collapsed') ? '+' : '−';
            });
        }
    </script>
</body>
</html>
