<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Euclidean Geometry Problem Viewer</title>

    <!-- Korean Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+KR:wght@400;600;700&display=swap" rel="stylesheet">
    
    <!-- Common Resources -->
    <link rel="stylesheet" href="styles/common.css">

    <!-- Import Map for ES Modules -->
    <script type="importmap">
    {
        "imports": {
            "p5": "https://esm.sh/p5@1.9.4"
        }
    }
    </script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <!-- UI Controls (legacy compatibility) -->
    <script src="https://euclide-worker.painfultrauma.workers.dev/lib/ui-controls.js"></script>
</head>
<body>
    <header class="top-nav">
        <a href="../" class="nav-logo">
            <!-- <i data-lucide="zap" width="18" height="18"></i> -->
            <span>MathMore</span>
        </a>
        <div class="auth-buttons">
            <button id="login-btn" onclick="signInWithGoogle()" style="display: none;">로그인</button>
            <button id="logout-btn" onclick="signOut()" style="display: none;">로그아웃</button>
        </div>
    </header>
    <main class="viewer-main">
        <div class="canvas-section">
            <div class="canvas-container" id="canvas-wrapper"></div>
        </div>
        
        <div class="content-section" id="scroll-container">
            <div id="problem-container"></div>
            <!-- Solution Panel - Below Canvas -->
            <div id="solution-panel" class="solution-panel hidden">
                <!-- <div class="solution-panel-header">
                    <span class="solution-panel-title">풀이</span>
                    <button id="solution-panel-close" class="solution-panel-close-btn">×</button>
                </div> -->
                <div class="solution-panel-content" id="solution-text"></div>
            </div>
        </div>
    </main>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="../js/auth.js"></script>
    <script>
        // Lucide 초기화
        lucide.createIcons();

        // 인증 초기화
        const loginBtn = document.getElementById('login-btn');
        const logoutBtn = document.getElementById('logout-btn');

        initAuth((session) => {
            if (session) {
                loginBtn.style.display = 'none';
                logoutBtn.style.display = 'block';
            } else {
                loginBtn.style.display = 'block';
                logoutBtn.style.display = 'none';
            }
        });

        // URL 파라미터에서 문제 ID 추출
        const urlParams = new URLSearchParams(window.location.search);
        const problemId = urlParams.get('problem') || '001';

        // Global variables for text update
        let globalPaddedId;
        let globalBaseUrl;

        // 문제 로드
        loadProblem(problemId);

        // Global state for contest mode
        let isContestMode = false;
        let canvasRevealed = false;

        async function loadProblem(id) {
            const paddedId = id.padStart(3, '0');
            const baseUrl = 'https://euclide-worker.painfultrauma.workers.dev';
            const configUrl = `${baseUrl}/problems/${paddedId}/config.json`;

            // Set global variables for updateProblemText
            globalPaddedId = paddedId;
            globalBaseUrl = baseUrl;

            // 캔버스를 초기에 숨김 (렌더링 안정화)
            const canvasWrapper = document.getElementById('canvas-wrapper');
            canvasWrapper.style.opacity = '0';
            canvasWrapper.style.visibility = 'hidden';

            try {
                const response = await fetch(configUrl);
                const config = await response.json();

                // 문제 텍스트와 UI를 먼저 렌더링
                await renderProblem(config, paddedId, baseUrl);

                // 모든 렌더링 완료 후 스케치 로드 (ES Module)
                const script = document.createElement('script');
                script.type = 'module';
                script.src = `${baseUrl}/problems/${paddedId}/sketch.js`;

                script.onload = () => {
                    // 컨트롤 생성
                    renderControls(config, paddedId, baseUrl);

                    // p5가 첫 프레임을 그릴 때까지 대기 후 캔버스 표시
                    function waitForP5Ready() {
                        if (window._p5Instance && window._p5Instance.frameCount > 0) {
                            if (!isContestMode) {
                                canvasWrapper.style.opacity = '1';
                                canvasWrapper.style.visibility = 'visible';
                            } else {
                                // Contest 모드: 캔버스가 열릴 때까지 애니메이션 정지
                                window._p5Instance.noLoop();
                            }
                        } else {
                            requestAnimationFrame(waitForP5Ready);
                        }
                    }
                    waitForP5Ready();
                };

                document.body.appendChild(script);
            } catch (error) {
                console.error('Failed to load problem:', error);
                document.getElementById('problem-container').innerHTML = `
                    <div class="error-message">
                        <h2>문제를 불러올 수 없습니다</h2>
                        <p>Problem ID: ${id}</p>
                        <p>${error.message}</p>
                    </div>
                `;
            }
        }

        async function renderProblem(config, paddedId, baseUrl) {
            // Pre-rendered HTML 로드
            try {
                const response = await fetch(`${baseUrl}/problems/${paddedId}/problem.html`);
                const html = await response.text();

                // config에서 contest 여부 확인
                isContestMode = config.contest === true;

                // 문제 HTML 생성
                const problemContainer = document.getElementById('problem-container');
                problemContainer.className = 'problem-container';
                problemContainer.innerHTML = `
                    <div class="problem-header">
                        <span class="problem-tag level">Level ${config.level}</span>
                        ${isContestMode ? '<span class="problem-tag contest">Contest</span>' : ''}
                    </div>
                    <div class="problem-content" id="problem-text"></div>
                    ${isContestMode ? '<button id="toggle-canvas-btn" class="toggle-canvas-btn">▼ 그림 보기</button>' : ''}
                `;

                // Pre-rendered HTML 삽입 (MathJax 불필요)
                const problemText = document.getElementById('problem-text');
                problemText.innerHTML = html;

                // Contest 문제면 캔버스 숨김 및 토글 설정
                if (isContestMode) {
                    const canvasWrapper = document.getElementById('canvas-wrapper');
                    canvasWrapper.style.display = 'none';

                    // 토글 버튼 이벤트
                    const toggleBtn = document.getElementById('toggle-canvas-btn');
                    toggleBtn.addEventListener('click', () => {
                        const isHidden = canvasWrapper.style.display === 'none';

                        if (isHidden) {
                            // 캔버스 펼치기
                            canvasWrapper.style.display = 'block';
                            canvasWrapper.style.opacity = '1';
                            canvasWrapper.style.visibility = 'visible';
                            toggleBtn.textContent = '▲ 그림 숨기기';

                            // 애니메이션 시작 (처음 펼칠 때만 리셋)
                            if (!canvasRevealed) {
                                canvasRevealed = true;
                                if (typeof resetAnimation === 'function') {
                                    resetAnimation();
                                }
                            }
                            // p5 루프 시작
                            if (window._p5Instance) {
                                window._p5Instance.loop();
                            }
                        } else {
                            // 캔버스 숨기기
                            canvasWrapper.style.display = 'none';
                            toggleBtn.textContent = '▼ 그림 보기';
                            // p5 루프 정지 (성능 최적화)
                            if (window._p5Instance) {
                                window._p5Instance.noLoop();
                            }
                        }
                    });
                }
            } catch (error) {
                console.error('Failed to load problem text:', error);
            }
        }

        // Cache for loaded phase contents
        const loadedPhasesCache = {};

        // Update problem text based on current mode and phase
        async function updateProblemText(mode, phase, paddedId, baseUrl) {
            if (mode === 'problem') {
                // Hide solution panel in problem mode
                hideSolutionPanel();

                // Ensure problem text shows problem.html
                const problemText = document.getElementById('problem-text');
                if (!problemText) return;

                try {
                    const response = await fetch(`${baseUrl}/problems/${paddedId}/problem.html`);
                    const html = await response.text();
                    problemText.innerHTML = html;
                } catch (error) {
                    console.error('Failed to load problem text:', error);
                }
            } else if (mode === 'solution') {
                const solutionText = document.getElementById('solution-text');
                if (!solutionText) return;

                showSolutionPanel();
                
                // Clear existing content to rebuild sequentially
                solutionText.innerHTML = '';
                
                const targetPhase = (phase === 'all' || !phase) ? (window.solutionPhaseCount || 1) : phase;
                
                for (let i = 1; i <= targetPhase; i++) {
                    await appendPhaseBlock(i, paddedId, baseUrl);
                }

                // Scroll to the bottom of the content section to show the newest phase
                const scrollContainer = document.getElementById('scroll-container');
                if (scrollContainer) {
                    setTimeout(() => {
                        scrollContainer.scrollTo({
                            top: scrollContainer.scrollHeight,
                            behavior: 'smooth'
                        });
                    }, 100);
                }
            }
        }

        async function appendPhaseBlock(phase, paddedId, baseUrl) {
            const solutionText = document.getElementById('solution-text');
            const cacheKey = `${paddedId}_${phase}`;
            
            let html;
            if (loadedPhasesCache[cacheKey]) {
                html = loadedPhasesCache[cacheKey];
            } else {
                try {
                    const response = await fetch(`${baseUrl}/problems/${paddedId}/solution-phase-${phase}.html`);
                    if (!response.ok) return;
                    html = await response.text();
                    loadedPhasesCache[cacheKey] = html;
                } catch (e) {
                    console.warn(`Failed to load phase ${phase}`);
                    return;
                }
            }

            const block = document.createElement('div');
            block.className = 'phase-block';
            block.innerHTML = `
                <div class="phase-block-title">Step ${phase}</div>
                <div class="phase-block-content">${html}</div>
            `;
            solutionText.appendChild(block);
        }

        function showSolutionPanel() {
            const panel = document.getElementById('solution-panel');
            if (panel) {
                panel.classList.remove('hidden');
            }
        }

        function hideSolutionPanel() {
            const panel = document.getElementById('solution-panel');
            if (panel) {
                panel.classList.add('hidden');
            }
        }

        function renderControls(config, paddedId, baseUrl) {
            const hasSolution = config.solutionPhases && config.solutionPhases.length > 0;
            // Store global solution phase count for sequential loading
            window.solutionPhaseCount = config.solutionPhases ? config.solutionPhases.length : 0;

            // Create controls inside canvas-wrapper
            const canvasWrapper = document.getElementById('canvas-wrapper');
            let controlsContainer = document.getElementById('controls-container');
            
            // Remove existing if any (cleanup)
            if (controlsContainer) {
                controlsContainer.remove();
            }
            
            controlsContainer = document.createElement('div');
            controlsContainer.id = 'controls-container';
            // Insert as first child to be behind canvas if z-index matches, 
            // but usually controls have higher z-index. 
            // Appending is safer for stacking context on top.
            canvasWrapper.appendChild(controlsContainer);

            controlsContainer.innerHTML = `
                <div class="controls collapsed" id="draggable-controls">
                    <!-- Header with drag handle and collapse -->
                    <div class="controls-header" id="controls-drag-handle">
                        <!-- Collapsed View: Mode Shortcuts -->
                        <div class="collapsed-view" style="display: none;">
                            <button class="mode-shortcut-btn" id="btn-shortcut-problem">Problem</button>
                            <button class="mode-shortcut-btn" id="btn-shortcut-solution" ${!hasSolution ? 'disabled' : ''}>Solution</button>
                        </div>
                        
                        <!-- Expanded View: Title -->
                        <span class="controls-title expanded-view">Controls</span>
                        
                        <button class="controls-collapse-btn" id="btn-collapse">+</button>
                    </div>

                    <div class="controls-body">
                        <!-- Mode Toggle -->
                        <div class="control-section mode-section">
                            <div class="control-label">Mode</div>
                            <div class="button-group mode-toggle">
                                <button id="btn-mode-problem" class="active mode-btn">Problem</button>
                                <button id="btn-mode-solution" class="mode-btn" ${!hasSolution ? 'disabled' : ''}>Solution</button>
                            </div>
                        </div>

                        <!-- Play Controls -->
                        <div class="control-section">
                            <div class="control-label">Play</div>
                            <div class="button-group">
                                <button id="btn-restart">↺</button>
                                <button id="btn-play-pause">⏸</button>
                            </div>
                        </div>

                        <!-- Phase Buttons -->
                        <div class="control-section">
                            <div class="control-label">Phase</div>
                            <div class="button-group" style="margin-bottom: 4px;">
                                <button id="btn-all" class="active">All</button>
                            </div>
                            <div class="phase-buttons" id="phase-buttons-container">
                                <!-- Dynamically populated -->
                            </div>
                        </div>
                    </div>
                </div>
            `;

            // Setup drag functionality for desktop
            setupDraggable();

            // Render initial phase buttons (problem mode)
            renderPhaseButtons('problem', config.problemPhases ? config.problemPhases.length : config.phases.length);

            // Setup event listeners (must be called after controls are rendered)
            if (typeof setupControls === 'function') {
                setupControls();
            }

            // Expand when clicking mode buttons if collapsed
            const expandOnModeClick = () => {
                const controls = document.getElementById('draggable-controls');
                if (controls && controls.classList.contains('collapsed')) {
                    toggleControls(controls, document.getElementById('btn-collapse'));
                }
            };
            document.getElementById('btn-mode-problem').addEventListener('click', expandOnModeClick);
            const solBtn = document.getElementById('btn-mode-solution');
            if (solBtn) solBtn.addEventListener('click', expandOnModeClick);

            // Shortcut Buttons Logic
            document.getElementById('btn-shortcut-problem').addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent drag start
                const probBtn = document.getElementById('btn-mode-problem');
                if (!probBtn.classList.contains('active')) {
                    probBtn.click();
                }
                // Ensure it expands
                const controls = document.getElementById('draggable-controls');
                if (controls.classList.contains('collapsed')) {
                     toggleControls(controls, document.getElementById('btn-collapse'));
                }
            });

            const shortSolBtn = document.getElementById('btn-shortcut-solution');
            if (shortSolBtn) {
                shortSolBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (!shortSolBtn.disabled) {
                        const solBtn = document.getElementById('btn-mode-solution');
                        if (!solBtn.classList.contains('active')) {
                            solBtn.click();
                        }
                        const controls = document.getElementById('draggable-controls');
                        if (controls.classList.contains('collapsed')) {
                            toggleControls(controls, document.getElementById('btn-collapse'));
                        }
                    }
                });
            }

            // Setup solution panel close button
            const closeBtn = document.getElementById('solution-panel-close');
            if (closeBtn) {
                closeBtn.addEventListener('click', () => {
                    hideSolutionPanel();
                });
            }
        }

        function toggleControls(controls, collapseBtn) {
            const isCollapsed = controls.classList.toggle('collapsed');
            collapseBtn.textContent = isCollapsed ? '+' : '−';
            
            // If expanding, ensure it's still within boundaries
            if (!isCollapsed) {
                const canvasWrapper = document.getElementById('canvas-wrapper');
                
                const currentLeft = controls.offsetLeft;
                const currentTop = controls.offsetTop;
                const controlWidth = controls.offsetWidth;
                const controlHeight = controls.offsetHeight;
                
                const maxLeft = canvasWrapper.clientWidth - controlWidth - 10; // 10px padding
                const maxTop = canvasWrapper.clientHeight - controlHeight - 10;
                
                if (currentLeft > maxLeft) controls.style.left = Math.max(0, maxLeft) + 'px';
                if (currentTop > maxTop) controls.style.top = Math.max(0, maxTop) + 'px';
            }
        }

        function renderPhaseButtons(mode, count) {
            const container = document.getElementById('phase-buttons-container');
            container.innerHTML = '';

            for (let i = 1; i <= count; i++) {
                const btn = document.createElement('button');
                btn.id = `btn-phase-${i}`;
                btn.setAttribute('data-phase', i);
                btn.textContent = `${i}`;
                container.appendChild(btn);
            }
        }

        // Draggable controls (desktop only)
        function setupDraggable() {
            const controls = document.getElementById('draggable-controls');
            const handle = document.getElementById('controls-drag-handle');
            const collapseBtn = document.getElementById('btn-collapse');

            if (!controls || !handle) return;

            // Check if mobile (don't enable drag on mobile)
            const isMobile = window.matchMedia('(max-width: 768px)').matches;
            if (isMobile) {
                controls.style.cursor = 'default';
                handle.style.cursor = 'default';
                return;
            }

            let isDragging = false;
            let startX, startY, initialLeft, initialTop;

            // Drag from header
            handle.addEventListener('mousedown', startDrag);

            function startDrag(e) {
                // Don't drag when clicking buttons
                if (e.target.tagName === 'BUTTON') return;
                isDragging = true;
                
                startX = e.clientX;
                startY = e.clientY;
                
                // Use offsetLeft/Top which is relative to the parent (canvas-wrapper)
                initialLeft = controls.offsetLeft;
                initialTop = controls.offsetTop;
                
                controls.style.transition = 'none';
                e.preventDefault();
            }

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                e.preventDefault();
                
                const canvasWrapper = document.getElementById('canvas-wrapper');
                
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                
                let newLeft = initialLeft + dx;
                let newTop = initialTop + dy;
                
                const controlWidth = controls.offsetWidth;
                const controlHeight = controls.offsetHeight;
                
                // Clamp within canvas boundaries (0 to width/height)
                const padding = 10;
                const maxLeft = canvasWrapper.clientWidth - controlWidth - padding;
                const maxTop = canvasWrapper.clientHeight - controlHeight - padding;
                
                newLeft = Math.max(padding, Math.min(newLeft, maxLeft));
                newTop = Math.max(padding, Math.min(newTop, maxTop));
                
                controls.style.left = newLeft + 'px';
                controls.style.top = newTop + 'px';
                controls.style.right = 'auto'; // Disable right alignment once moved
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    controls.style.transition = '';
                }
            });

            // 창 크기 변경 시 컨트롤 위치 조정
            window.addEventListener('resize', () => {
                if (window.matchMedia('(max-width: 768px)').matches) return;
                
                const canvasWrapper = document.getElementById('canvas-wrapper');
                if (!canvasWrapper || !controls) return;

                const padding = 10;
                const controlWidth = controls.offsetWidth;
                const controlHeight = controls.offsetHeight;
                
                const maxLeft = canvasWrapper.clientWidth - controlWidth - padding;
                const maxTop = canvasWrapper.clientHeight - controlHeight - padding;
                
                let currentLeft = controls.offsetLeft;
                let currentTop = controls.offsetTop;
                
                // 영역 밖으로 나갔다면 안으로 밀어넣기
                if (currentLeft > maxLeft || currentTop > maxTop) {
                    const newLeft = Math.max(padding, Math.min(currentLeft, maxLeft));
                    const newTop = Math.max(padding, Math.min(currentTop, maxTop));
                    
                    controls.style.left = newLeft + 'px';
                    controls.style.top = newTop + 'px';
                }
            });

            // Collapse/expand functionality
            collapseBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleControls(controls, collapseBtn);
            });
        }
    </script>
</body>
</html>
