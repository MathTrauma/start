<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Euclidean Geometry Problem Viewer</title>

    <!-- Korean Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+KR:wght@400;600;700&display=swap" rel="stylesheet">
    
    <!-- Common Resources -->
    <link rel="stylesheet" href="styles/common.css">

    <!-- Import Map for ES Modules -->
    <script type="importmap">
    {
        "imports": {
            "p5": "https://esm.sh/p5@1.9.4"
        }
    }
    </script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <!-- UI Controls (legacy compatibility) -->
    <script src="https://euclide-worker.painfultrauma.workers.dev/lib/ui-controls.js"></script>
</head>
<body>
    <header class="top-nav">
        <a href="../" class="nav-logo">
            <span>MathMore</span>
        </a>
        <div class="auth-buttons">
            <button id="login-btn" onclick="signInWithGoogle()" style="display: none;">로그인</button>
            <button id="logout-btn" onclick="signOut()" style="display: none;">로그아웃</button>
        </div>
    </header>
    <main class="viewer-main">
        <div class="content-section" id="problem-scroll-container">
            <div id="problem-container"></div>
        </div>

        <div class="canvas-section">
            <div class="canvas-container" id="canvas-wrapper"></div>
        </div>
        
        <div class="content-section" id="solution-scroll-container">
            <div id="solution-panel" class="solution-panel hidden">
                <div class="solution-panel-content" id="solution-text"></div>
            </div>
        </div>
    </main>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="../js/auth.js"></script>
    <script>
        lucide.createIcons();

        const loginBtn = document.getElementById('login-btn');
        const logoutBtn = document.getElementById('logout-btn');

        initAuth((session) => {
            if (session) {
                loginBtn.style.display = 'none';
                logoutBtn.style.display = 'block';
            } else {
                loginBtn.style.display = 'block';
                logoutBtn.style.display = 'none';
            }
        });

        const urlParams = new URLSearchParams(window.location.search);
        const problemId = urlParams.get('problem') || '001';

        let globalPaddedId;
        let globalBaseUrl;

        loadProblem(problemId);

        let isContestMode = false;
        let canvasRevealed = false;

        async function loadProblem(id) {
            const paddedId = id.padStart(3, '0');
            const baseUrl = 'https://euclide-worker.painfultrauma.workers.dev';
            const configUrl = `${baseUrl}/problems/${paddedId}/config.json`;

            globalPaddedId = paddedId;
            globalBaseUrl = baseUrl;

            const canvasWrapper = document.getElementById('canvas-wrapper');
            canvasWrapper.style.opacity = '0';
            canvasWrapper.style.visibility = 'hidden';

            try {
                const response = await fetch(configUrl);
                const config = await response.json();

                await renderProblem(config, paddedId, baseUrl);

                const script = document.createElement('script');
                script.type = 'module';
                script.src = `${baseUrl}/problems/${paddedId}/sketch.js`;

                script.onload = () => {
                    renderControls(config, paddedId, baseUrl);

                    function waitForP5Ready() {
                        if (window.p5Instance && window.p5Instance.frameCount > 0) {
                            if (!isContestMode) {
                                canvasWrapper.style.opacity = '1';
                                canvasWrapper.style.visibility = 'visible';
                            } else {
                                window.p5Instance.noLoop();
                            }
                        } else {
                            requestAnimationFrame(waitForP5Ready);
                        }
                    }
                    waitForP5Ready();
                };

                document.body.appendChild(script);
            } catch (error) {
                console.error('Failed to load problem:', error);
                document.getElementById('problem-container').innerHTML = `
                    <div class="error-message">
                        <h2>문제를 불러올 수 없습니다</h2>
                        <p>Problem ID: ${id}</p>
                        <p>${error.message}</p>
                    </div>
                `;
            }
        }

        async function renderProblem(config, paddedId, baseUrl) {
            try {
                const response = await fetch(`${baseUrl}/problems/${paddedId}/problem.html`);
                const html = await response.text();

                isContestMode = config.contest === true;

                const problemContainer = document.getElementById('problem-container');
                problemContainer.className = 'problem-container';
                problemContainer.innerHTML = `
                    <div class="problem-content">
                        <span class="problem-tag level">L${config.level}</span>
                        ${isContestMode ? '<span class="problem-tag contest">Contest</span>' : ''}
                        <span id="problem-text"></span>
                    </div>
                    ${isContestMode ? '<button id="toggle-canvas-btn" class="toggle-canvas-btn">▼ 그림 보기</button>' : ''}
                `;

                const problemText = document.getElementById('problem-text');
                problemText.innerHTML = html;

                if (isContestMode) {
                    const canvasWrapper = document.getElementById('canvas-wrapper');
                    canvasWrapper.style.display = 'none';

                    const toggleBtn = document.getElementById('toggle-canvas-btn');
                    toggleBtn.addEventListener('click', () => {
                        const isHidden = canvasWrapper.style.display === 'none';

                        if (isHidden) {
                            canvasWrapper.style.display = 'block';
                            canvasWrapper.style.opacity = '1';
                            canvasWrapper.style.visibility = 'visible';
                            toggleBtn.textContent = '▲ 그림 숨기기';

                            if (!canvasRevealed) {
                                canvasRevealed = true;
                                if (typeof resetAnimation === 'function') {
                                    resetAnimation();
                                }
                            }
                            if (window.p5Instance) {
                                window.p5Instance.loop();
                            }
                        } else {
                            canvasWrapper.style.display = 'none';
                            toggleBtn.textContent = '▼ 그림 보기';
                            if (window.p5Instance) {
                                window.p5Instance.noLoop();
                            }
                        }
                    });
                }
            } catch (error) {
                console.error('Failed to load problem text:', error);
            }
        }

        const loadedPhasesCache = {};

        async function updateProblemText(mode, phase, paddedId, baseUrl) {
            if (mode === 'problem') {
                hideSolutionPanel();
                const problemText = document.getElementById('problem-text');
                if (!problemText) return;
                try {
                    const response = await fetch(`${baseUrl}/problems/${paddedId}/problem.html`);
                    const html = await response.text();
                    problemText.innerHTML = html;
                } catch (error) {
                    console.error('Failed to load problem text:', error);
                }
            } else if (mode === 'solution') {
                const solutionText = document.getElementById('solution-text');
                if (!solutionText) return;
                showSolutionPanel();
                solutionText.innerHTML = '';
                const targetPhase = (phase === 'all' || !phase) ? (window.solutionPhaseCount || 1) : phase;
                for (let i = 1; i <= targetPhase; i++) {
                    await appendPhaseBlock(i, paddedId, baseUrl);
                }
                const scrollContainer = document.getElementById('solution-scroll-container');
                if (scrollContainer) {
                    setTimeout(() => {
                        scrollContainer.scrollTo({
                            top: scrollContainer.scrollHeight,
                            behavior: 'smooth'
                        });
                    }, 100);
                }
            }
        }

        async function appendPhaseBlock(phase, paddedId, baseUrl) {
            const solutionText = document.getElementById('solution-text');
            const cacheKey = `${paddedId}_${phase}`;
            let html;
            if (loadedPhasesCache[cacheKey]) {
                html = loadedPhasesCache[cacheKey];
            } else {
                try {
                    const response = await fetch(`${baseUrl}/problems/${paddedId}/solution-phase-${phase}.html`);
                    if (!response.ok) return;
                    html = await response.text();
                    loadedPhasesCache[cacheKey] = html;
                } catch (e) {
                    console.warn(`Failed to load phase ${phase}`);
                    return;
                }
            }
            const block = document.createElement('div');
            block.className = 'phase-block';
            block.innerHTML = `
                <div class="phase-block-title">Step ${phase}</div>
                <div class="phase-block-content">${html}</div>
            `;
            solutionText.appendChild(block);
        }

        function showSolutionPanel() {
            const panel = document.getElementById('solution-panel');
            if (panel) panel.classList.remove('hidden');
        }

        function hideSolutionPanel() {
            const panel = document.getElementById('solution-panel');
            if (panel) panel.classList.add('hidden');
        }

        function renderControls(config, paddedId, baseUrl) {
            const hasSolution = config.solutionPhases && config.solutionPhases.length > 0;
            window.solutionPhaseCount = config.solutionPhases ? config.solutionPhases.length : 0;
            const canvasWrapper = document.getElementById('canvas-wrapper');
            let controlsContainer = document.getElementById('controls-container');
            if (controlsContainer) controlsContainer.remove();
            controlsContainer = document.createElement('div');
            controlsContainer.id = 'controls-container';
            canvasWrapper.appendChild(controlsContainer);
            controlsContainer.innerHTML = `
                <div class="controls collapsed" id="draggable-controls">
                    <div class="controls-header" id="controls-drag-handle">
                        <div class="collapsed-view" style="display: none;">
                            <button class="mode-shortcut-btn" id="btn-shortcut-problem">Problem</button>
                            <button class="mode-shortcut-btn" id="btn-shortcut-solution" ${!hasSolution ? 'disabled' : ''}>Solution</button>
                        </div>
                        <span class="controls-title expanded-view">Controls</span>
                        <button class="controls-collapse-btn" id="btn-collapse">+</button>
                    </div>
                    <div class="controls-body">
                        <div class="control-section mode-section">
                            <div class="control-label">Mode</div>
                            <div class="button-group mode-toggle">
                                <button id="btn-mode-problem" class="active mode-btn">Problem</button>
                                <button id="btn-mode-solution" class="mode-btn" ${!hasSolution ? 'disabled' : ''}>Solution</button>
                            </div>
                        </div>
                        <div class="control-section">
                            <div class="control-label">Play</div>
                            <div class="button-group">
                                <button id="btn-restart">↺</button>
                                <button id="btn-play-pause">⏸</button>
                            </div>
                        </div>
                        <div class="control-section">
                            <div class="control-label">Phase</div>
                            <div class="button-group" style="margin-bottom: 4px;">
                                <button id="btn-all" class="active">All</button>
                            </div>
                            <div class="phase-buttons" id="phase-buttons-container"></div>
                        </div>
                    </div>
                </div>
            `;
            setupDraggable();
            renderPhaseButtons('problem', config.problemPhases ? config.problemPhases.length : config.phases.length);
            if (typeof setupControls === 'function') setupControls();

            const expandOnModeClick = () => {
                const controls = document.getElementById('draggable-controls');
                if (controls && controls.classList.contains('collapsed')) {
                    toggleControls(controls, document.getElementById('btn-collapse'));
                }
            };
            document.getElementById('btn-mode-problem').addEventListener('click', expandOnModeClick);
            const solBtn = document.getElementById('btn-mode-solution');
            if (solBtn) solBtn.addEventListener('click', expandOnModeClick);

            document.getElementById('btn-shortcut-problem').addEventListener('click', (e) => {
                e.stopPropagation();
                const controls = document.getElementById('draggable-controls');
                const probBtn = document.getElementById('btn-mode-problem');
                if (controls.classList.contains('collapsed')) {
                    if (!probBtn.classList.contains('active')) probBtn.click();
                    toggleControls(controls, document.getElementById('btn-collapse'));
                } else {
                    if (probBtn.classList.contains('active')) toggleControls(controls, document.getElementById('btn-collapse'));
                    else probBtn.click();
                }
            });

            const shortSolBtn = document.getElementById('btn-shortcut-solution');
            if (shortSolBtn) {
                shortSolBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (shortSolBtn.disabled) return;
                    const controls = document.getElementById('draggable-controls');
                    const solBtn = document.getElementById('btn-mode-solution');
                    if (controls.classList.contains('collapsed')) {
                        if (!solBtn.classList.contains('active')) solBtn.click();
                        toggleControls(controls, document.getElementById('btn-collapse'));
                    } else {
                        if (solBtn.classList.contains('active')) toggleControls(controls, document.getElementById('btn-collapse'));
                        else solBtn.click();
                    }
                });
            }
        }

        function toggleControls(controls, collapseBtn) {
            const isCollapsed = controls.classList.toggle('collapsed');
            collapseBtn.textContent = isCollapsed ? '+' : '−';
            if (!isCollapsed) {
                const canvasWrapper = document.getElementById('canvas-wrapper');
                const currentLeft = controls.offsetLeft;
                const currentTop = controls.offsetTop;
                const maxLeft = canvasWrapper.clientWidth - controls.offsetWidth - 10;
                const maxTop = canvasWrapper.clientHeight - controls.offsetHeight - 10;
                if (currentLeft > maxLeft) controls.style.left = Math.max(0, maxLeft) + 'px';
                if (currentTop > maxTop) controls.style.top = Math.max(0, maxTop) + 'px';
            }
        }

        function renderPhaseButtons(mode, count) {
            const container = document.getElementById('phase-buttons-container');
            container.innerHTML = '';
            for (let i = 1; i <= count; i++) {
                const btn = document.createElement('button');
                btn.id = `btn-phase-${i}`;
                btn.setAttribute('data-phase', i);
                btn.textContent = `${i}`;
                container.appendChild(btn);
            }
        }

        function setupDraggable() {
            const controls = document.getElementById('draggable-controls');
            const handle = document.getElementById('controls-drag-handle');
            const collapseBtn = document.getElementById('btn-collapse');
            if (!controls || !handle) return;
            let isDragging = false;
            let startX, startY, initialLeft, initialTop;
            handle.addEventListener('mousedown', startDrag);
            handle.addEventListener('touchstart', startDrag, { passive: false });
            function startDrag(e) {
                if (e.target.tagName === 'BUTTON') return;
                isDragging = true;
                const clientX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
                const clientY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;
                startX = clientX;
                startY = clientY;
                initialLeft = controls.offsetLeft;
                initialTop = controls.offsetTop;
                controls.style.transition = 'none';
                if (e.type === 'touchstart') e.preventDefault();
            }
            const onMove = (e) => {
                if (!isDragging) return;
                const clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
                const clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;
                const canvasWrapper = document.getElementById('canvas-wrapper');
                const dx = clientX - startX;
                const dy = clientY - startY;
                let newLeft = initialLeft + dx;
                let newTop = initialTop + dy;
                const padding = 5;
                const maxLeft = canvasWrapper.clientWidth - controls.offsetWidth - padding;
                const maxTop = canvasWrapper.clientHeight - controls.offsetHeight - padding;
                newLeft = Math.max(padding, Math.min(newLeft, maxLeft));
                newTop = Math.max(padding, Math.min(newTop, maxTop));
                controls.style.left = newLeft + 'px';
                controls.style.top = newTop + 'px';
                controls.style.right = 'auto';
                if (e.type === 'touchmove') e.preventDefault();
            };
            const endDrag = () => {
                if (isDragging) {
                    isDragging = false;
                    controls.style.transition = '';
                }
            };
            document.addEventListener('mousemove', onMove);
            document.addEventListener('touchmove', onMove, { passive: false });
            document.addEventListener('mouseup', endDrag);
            document.addEventListener('touchend', endDrag);
            collapseBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleControls(controls, collapseBtn);
            });
        }
    </script>
</body>
</html>