
import p5 from 'p5';
import { applyTheme, getCanvasSize } from '../../lib/draw-utils.js';
import { circleLineIntersection, intersectLines } from '../../lib/geometry.js';
import { XAnimator } from '../../lib/x_animator.js';
import { XPolygon, XSegment, XPoint, XArc, XDimension, XObject } from '../../lib/x_object.js';
import { COLORS } from '../../lib/config.js';
import { sketchContext } from '../../lib/sketch-context.js';

const sketch = (p) => {
    let A, B, C, M, D, E, F, G;
    let animator;

    p.setup = function () {
        const size = getCanvasSize(600, 20);
        p.createCanvas(size, size);
        p.pixelDensity(window.devicePixelRatio || 1);

        const params = new URLSearchParams(window.location.search);
        applyTheme(p, params.get('theme') || undefined);

        // 기본 점 정의
        B = p.createVector(-15, 0);
        C = p.createVector(15, 0);
        M = p5.Vector.add(B, C).div(2);  // BC의 중점

        // A 계산: AB=27, AC=39
        // A(x, y): (x+15)² + y² = 729, (x-15)² + y² = 1521
        // 60x = -792 => x = -13.2
        // y² = 729 - (1.8)² = 725.76
        const ax = -13.2;
        const ay = Math.sqrt(729 - Math.pow(ax + 15, 2));
        A = p.createVector(ax, ay);

        // D: BC를 지름으로 하는 원(반원)과 직선 AM의 교점
        const radius = 15;
        // AM 직선 위의 다른 점 (M에서 A 방향으로 연장)
        const AMextend = p5.Vector.sub(M, A).add(M);
        const intersectionsD = circleLineIntersection(M, radius, A, AMextend);
        // y > 0인 점 선택 (A가 아닌 점)
        D = intersectionsD.find(pt => pt.y > 0.1 && p5.Vector.dist(pt, A) > 0.1) || intersectionsD[0];

        // E: 직선 CD와 AB의 교점
        E = intersectLines(C, D, A, B);

        // F: 직선 BD와 AC의 교점
        F = intersectLines(B, D, A, C);

        // G: 직선 AD와 EF의 교점
        G = intersectLines(A, D, E, F);

        // 중심점 (레이블 배치용)
        const center = p.createVector(
            (A.x + B.x + C.x) / 3,
            (A.y + B.y + C.y) / 3
        );

        // 테마 색상
        const t = p.theme;
        const fillColor1 = [...t.fillBlue.slice(0, 3), 60];
        const fillColor2 = [...t.fillRed.slice(0, 3), 60];
        const fillColor3 = [100, 255, 150, 60];
        const fillColor4 = [255, 200, 100, 60];

        // Animator 초기화
        animator = new XAnimator(p);
        animator.initViewport([A, B, C], size);

        // ===== Problem Phases =====

        // Phase 1: 삼각형 ABC와 반원
        animator.registerPhase('problem1', [
            { id: 'triABC', object: new XPolygon(p, [A, B, C]), animate: { mode: 'draw', duration: 1.2 } },
            { delay: 0.2 },
            {
                group: [
                    { id: 'pointA', object: new XPoint(p, A, 'A', { center }), animate: { mode: 'draw', duration: 0.3 } },
                    { id: 'pointB', object: new XPoint(p, B, 'B', { center }), animate: { mode: 'draw', duration: 0.3 } },
                    { id: 'pointC', object: new XPoint(p, C, 'C', { center }), animate: { mode: 'draw', duration: 0.3 } }
                ],
                parallel: true
            },
            {
                group: [
                    { id: 'dimBA', object: new XDimension(p, B, A, '27', { offset: 10 }), animate: { mode: 'draw', duration: 1.5 } },
                    { id: 'dimBC', object: new XDimension(p, B, C, '30', { offset: -10 }), animate: { mode: 'draw', duration: 1.5 } }
                ],
                parallel: true
            },
            { delay: 1.0 },
            // 반원 그리기 (y > 0 부분만)
            { id: 'semicircle', object: XArc(p, M, radius, 0, Math.PI, { filled: false }), animate: { mode: 'draw', duration: 1.5 } },
            { delay: 0.2 },
            { id: 'segAM', object: XSegment(p, A, M), animate: { mode: 'draw', duration: 1.2 } },
            {
                group: [
                    { id: 'pointM', object: new XPoint(p, M, 'M', { dy: 10 }), animate: { mode: 'draw', duration: 0.3 } },
                    { id: 'pointD', object: new XPoint(p, D, 'D', { dx: 10 }), animate: { mode: 'draw', duration: 0.3 } }
                ],
                parallel: true
            },
            { id: 'dimDM', object: new XDimension(p, D, M, '15', { offset: 10 }), animate: { mode: 'draw', duration: 1.0 } },
            { delay: 1.0 }
        ]);

        // Phase 2: 보조선들
        animator.registerPhase('problem2', [
            {
                group: [
                    { id: 'segBF', object: XSegment(p, B, F), animate: { mode: 'draw', duration: 1.2 } },
                    { id: 'segCE', object: XSegment(p, C, E), animate: { mode: 'draw', duration: 1.2 } }
                ],
                parallel: true
            },
            { delay: 0.2 },
            {
                group: [
                    { id: 'pointE', object: new XPoint(p, E, 'E', { dx: -10 }), animate: { mode: 'draw', duration: 0.3 } },
                    { id: 'pointF', object: new XPoint(p, F, 'F', { dx: 10 }), animate: { mode: 'draw', duration: 0.3 } }
                ],
                parallel: true
            },
            { delay: 0.2 },
            { id: 'segEF', object: XSegment(p, E, F), animate: { mode: 'draw', duration: 1.0 } },
            { id: 'dimEF', object: new XDimension(p, E, F, '10', { offset: 10 }), animate: { mode: 'draw', duration: 0.8 } },
            { delay: 1.0 }
        ]);

        // ===== Solution Phases =====

        // 스크린 좌표 기준 텍스트 위치 (upper center)
        const LINE_HEIGHT = 28;
        const baseX = size / 2;  // 중앙
        const baseY = 20;

        // XObject 직접 생성 + _renderText 사용 (screenCoord: true)
        const textCeva = new XObject(p, {});
        textCeva.render = function() {
            if (!this.visible) return;
            this._renderText('체바정리', baseX, baseY, { fontSize: 18, screenCoord: true });
        };

        const formula1 = new XObject(p, {});
        formula1.render = function() {
            if (!this.visible) return;
            this._renderText('\\frac{\\overline{AE}}{\\overline{EB}} \\cdot \\frac{\\overline{BM}}{\\overline{MC}} \\cdot \\frac{\\overline{CF}}{\\overline{FA}}=1', baseX, baseY + LINE_HEIGHT, { fontSize: 14, useTex: true, screenCoord: true });
        };

        const formula2 = new XObject(p, {});
        formula2.render = function() {
            if (!this.visible) return;
            this._renderText('\\frac{\\overline{AE}}{\\overline{EB}} = \\frac{\\overline{AF}}{\\overline{FC}} \\Longrightarrow EF \\parallel BC', baseX, baseY + LINE_HEIGHT * 2, { fontSize: 14, useTex: true, screenCoord: true });
        };

        // frameCallback: offset 슬라이더
        const createOffsetSlider = (toOffset, duration) => {
            let elapsed = 0, lastTime = null, fromOffset = null;
            return (obj) => {
                if (fromOffset === null) fromOffset = obj.offset;
                const now = performance.now();
                if (!lastTime) lastTime = now;
                elapsed += (now - lastTime) / 1000;
                lastTime = now;
                const progress = Math.min(1, elapsed / duration);
                obj.offset = fromOffset + (toOffset - fromOffset) * progress;
                if (progress >= 1) obj.frameCallback = null;
            };
        };

        // Solution Phase 1: 체바정리 텍스트
        animator.registerPhase('solution1', [
            { id: 'textCeva', object: textCeva, animate: { mode: 'draw', duration: 0.7 } },
            { id: 'formula1', object: formula1, animate: { mode: 'draw', duration: 1.5 } },
            { id: 'formula2', object: formula2, animate: { mode: 'draw', duration: 1.5 } },
            { delay: 2.0 }
        ]);

        // Solution Phase 2: 닮음 I (DBC, DFE)
        // filldraw + travel 동시 실행 (2.5s)
        animator.registerPhase('solution2', [
            {
                group: [
                    { id: 'triDBC', object: new XPolygon(p, [D, B, C], { filled: true, fillColor: fillColor1 }), animate: { mode: 'draw', duration: 2.5 } },
                    { id: 'triDFE', object: new XPolygon(p, [D, F, E], { filled: true, fillColor: fillColor2 }), animate: { mode: 'draw', duration: 2.5 } },
                    // draw와 travel 동시 시작 - travel은 delay 후 시작하여 draw 완료 시점에 맞춤
                    {
                        group: [
                            { delay: 0.5 },
                            {
                                group: [
                                    { id: 'triDBC', animate: { mode: 'travel', duration: 2.0 } },
                                    { id: 'triDFE', animate: { mode: 'travel', duration: 2.0 } }
                                ],
                                parallel: true
                            }
                        ],
                        parallel: false
                    }
                ],
                parallel: true
            },
            { delay: 0.3 },
            { id: 'pointG', object: new XPoint(p, G, 'G', { dx: 10 }), animate: { mode: 'draw', duration: 0.3 } },
            { id: 'dimGD', object: new XDimension(p, G, D, '5', { offset: 10 }), animate: { mode: 'draw', duration: 1.0 } },
            { delay: 2.0 },
            {
                group: [
                    { id: 'triDBC', action: 'hide', duration: 0.5 },
                    { id: 'triDFE', action: 'hide', duration: 0.5 }
                ],
                parallel: true
            }
        ]);

        // Solution Phase 3: 닮음 II (AEF, ABC)
        // filldraw + travel 동시 실행 (2.5s)
        animator.registerPhase('solution3', [
            {
                group: [
                    { id: 'triAEF', object: new XPolygon(p, [A, E, F], { filled: true, fillColor: fillColor3 }), animate: { mode: 'draw', duration: 2.5 } },
                    { id: 'triABC2', object: new XPolygon(p, [A, B, C], { filled: true, fillColor: fillColor4 }), animate: { mode: 'draw', duration: 2.5 } },
                    // draw와 travel 동시 시작 - travel은 delay 후 시작하여 draw 완료 시점에 맞춤
                    {
                        group: [
                            { delay: 0.5 },
                            {
                                group: [
                                    { id: 'triAEF', animate: { mode: 'travel', duration: 2.0 } },
                                    { id: 'triABC2', animate: { mode: 'travel', duration: 2.0 } }
                                ],
                                parallel: true
                            }
                        ],
                        parallel: false
                    }
                ],
                parallel: true
            },
            { delay: 0.3 },
            // XDim AG + offset 변경 + XDim GM 병렬 실행
            {
                group: [
                    { id: 'dimAG', object: new XDimension(p, A, G, '10', { offset: 10, color: COLORS.green }), animate: { mode: 'draw', duration: 1.0 } },
                    { id: 'dimGD', setFrameCallbackFactory: () => createOffsetSlider(-10, 1.5) },
                    { id: 'dimDM', setFrameCallbackFactory: () => createOffsetSlider(-10, 1.5) },
                    { id: 'dimGM', object: new XDimension(p, G, M, '20', { offset: 10, color: COLORS.green }), animate: { mode: 'draw', duration: 1.5 } }
                ],
                parallel: true
            },
            { delay: 2.0 }
        ]);

        const phaseMap = {
            problem: {
                1: 'problem1',
                2: 'problem2'
            },
            solution: {
                1: 'solution1',
                2: 'solution2',
                3: 'solution3'
            }
        };

        sketchContext.register({
            p5Instance: p,
            animator: animator,
            phaseMap: phaseMap,
            problemPhaseCount: 2,
            solutionPhaseCount: 3
        });
    };

    p.draw = function () {
        p.background(p.theme.background);

        p.push();
        p.translate(p.width / 2, p.height / 2);
        p.scale(1, -1);

        if (animator) {
            animator.updateAndDraw();
        }

        p.pop();
    };
};

new p5(sketch, 'canvas-wrapper');
